%Semantics of state charts
\section{Semantics of \plcchart}
\label{sec:statechartsem}

The semantics used for our project was purposely modelled after \emphasize{UML2 State Machine Diagram}\cite{UML2}. As discussed in section \ref{sec:overviewstatechart} UML2 is essentially standard staet machine with extensions added on to describe behaviours in states. The motivation to using \emphasize{UML2 State Machine Diagram}\cite{UML2} as a basis for our state machine system consists of three primary details. First \emphasize{UML2 State Machine Diagram}\cite{UML2} is quite well known and popular, this improves the potential acceptance of our tool. Secondly \emphasize{UML2 State Machine Digram}\cite{UML2} state machine syntax is more concrete than the other forms of state machines, giving a strong basis to construct our language around. Finally \emphasize{UML2 State Machine Diagram}\cite{UML2} has the concept of internal activity or internal execution necessary for modelling the behaviour of an actual useful program.

The semantics of \plcchart is expressed mathematically as follows:

\begin{definition}
	\plcchart
	
\begin{itemize}
	\item \textbf{$Q$:} Set of modes.
	\item \textbf{$V$:} Vector of state spaces $V = \langle V_0,V_1,V_2,..,V_n \rangle \: where \: V_{0..n}\in \lbrace \mathbb{Z}_{128}, \mathbb{Z}, \mathbb{B}, \mathbb{R} \rbrace$
	\item $\mathbf{v}_{init}$: vector of intial values $\mathbf{v}_{init}$: $\lbrace v_0,..,v_n \rbrace \: where \: (v_i \in V_i)$
	\item \textbf{$G$:} Set of guard conditions. $V \rightarrow \mathbb{B}$
	\item \textbf{$A$:} Set of assignments. $V \times Q \rightarrow V$
	\item \textbf{$\tau$:} Set of transitions. $G \times Q \rightarrow Q$
	\item \textbf{$q_0$:} An initial starting mode.
\end{itemize}
\end{definition}

A mode in \plccharts may have many have many different states. For example in a finite state machine we may have states (1) and (2) if we add modes then we have (0,1), (0,2). We can say that both states are in the same mode 0 but have different values. State spaces in our system are used for variable assignments when a variable is typed it is assigned a state space, for example $V_0 \in \mathbb{Z}$ states that we have the a variable of type $\mathbb{Z}$. Initial values in our system is a vector of elements that come from the state spaces that is defined by $V$ that they are type restricted by what we choose for $V$. This is to ensure that if we have $V_0 = \mathbb{Z}$ we always will assign $v_0$ to be of type $\mathbb{Z}$ and this cannot be changed throughout the entire model. Guard conditions are mappings from states spaces onto boolean values for example if our state space is {1,(2,3)} $(1) \rightarrow true$, $(2,3) \rightarrow false$ would be two guard conditions.

Assignments in our system take the form $V x Q \rightarrow V$ suppose we have variables $v_0,v_1,v_2$ mode $q_1$ one possible assignment is then $(v_0,q_1) \rightarrow (v_1)$. In this case we choose to update $v_1$ after looking at $v_0$ in $q_1$.   

\begin{verbatim}
!!!!!!!!!!!!I'm not sure what you mean by mixing syntax!!! 
!!!!!!!!!!!!and semantics with the below section)!!!!!!!!!!!!!!
\end{verbatim}

Assignments in \plccharts happen in sequence rather than all at once this method was chosen to allow sequential forumlae to be computed in our system easily. Assignments can be in the form of a constant or an equation. If a series of assignment were found in a single mode as follows:

\begin{align}
v_1 := v_0 \label{eqn:assign0} \\ 
v_0 := v_1 \label{eqn:assign1}
\end{align}

We would see that the result $v_1 = v_0$ it is important to note this since generally in \emphasize{Finite State Machines}\cite{booth}  it is understood that assignments happen cocurrently in such a case equations \ref{eqn:assign0} and \ref{eqn:assign1} would produce a swap where $v'_1 = 'v_0$ and $v'_0 = 'v_1$ (where $'v$ denotes the value of $v$ before the assignments are executed and $v'$ the value of $v$ after the assignment is completed). In normal state machines we read assignments such as in equations \ref{eqn:assign0} and \ref{eqn:assign1} as these assignments will take place upon entry of the state. For our semantics however, we read them in a sequential fashion for example: Upon entry of the mode, first equation \ref{eqn:assign0} is assigned, then \ref{eqn:assign1} right afterwards.

\begin{figure}[htp]
    \centering
    \includegraphics[trim= 10mm 145mm 10mm 10mm, clip, width=\imgmedium]{./images/state_uml2_fir.pdf}
    \caption{5 Tap Fir Filtering}
    \label{fig:state_uml2_fir}
\end{figure}

The advantage of sequential assignments over cocurrent assignments can be seen when trying to compute the 5 stage fir filter as seen in figure \ref{fig:state_uml2_fir}. In figure \ref{fig:state_uml2_fir} sequential assignments are very useful for the initial step without it many more modes would be required to do each simple assignement. Thus although this design choice slightly deviates from \emphasize{UML2 State Machine Diagram}\cite{UML2} it was decided the benefits to usability was too great to strictly adhere to the \emphasize{UML2 State Machine Diagram}\cite{UML2} semantics.

\begin{figure}[htp]
    \centering
    \includegraphics[width=230px]{./images/tool_transition_example.png}
    \caption{PLC Edit Example}
    \label{fig:tool_transition_example}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=230px]{./images/tool_transition_example_bad.png}
    \caption{PLC Edit Example With Bad Transitions}
    \label{fig:tool_transition_example_bad}
\end{figure}

Transitions in the language must be mutually exclusive that is if it is invalid to have two transitions that can both be taken at any point. Figure \ref{fig:tool_transition_example} shows an example of this done correctly the two guard conditions ``count $<$ 10'' and ``count $\geq$ 10'' ensure mutal exclusivity. When mutual exclusion is not ensured such as in figure \ref{fig:tool_transition_example_bad} the language is undefined. \plccharts currently does not allow for cocurrent execution. Therefore when drawn in our language this would be ambiguous and the outcome (as in which edge would be taken) is undefined.